"use strict";
// -------------------------------------------------------------
// WARNING: this file is used by both the client and the server.
// Do not use any browser or node-specific API!
// -------------------------------------------------------------
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("../types");
const error_hints_1 = __importDefault(require("../../browser/connection/error-hints"));
const string_1 = require("../../utils/string");
const skip_js_errors_option_names_1 = require("../../configuration/skip-js-errors-option-names");
const DOCUMENTATION_LINKS = {
    TEST_SOURCE_PARAMETER: 'https://testcafe.io/documentation/402639/reference/command-line-interface#file-pathglob-pattern',
    FILTER_SETTINGS: 'https://testcafe.io/documentation/402638/reference/configuration-file#filter',
    HEADLESS_MODE: 'https://testcafe.io/documentation/402828/guides/concepts/browsers#test-in-headless-mode',
    CUSTOM_ACTIONS: 'https://testcafe.io/documentation/404150/guides/advanced-guides/custom-test-actions',
};
exports.default = {
    [types_1.RUNTIME_ERRORS.cannotCreateMultipleLiveModeRunners]: 'Cannot launch multiple live mode instances of the TestCafe test runner.',
    [types_1.RUNTIME_ERRORS.cannotRunLiveModeRunnerMultipleTimes]: 'Cannot launch the same live mode instance of the TestCafe test runner multiple times.',
    [types_1.RUNTIME_ERRORS.browserDisconnected]: 'The {userAgent} browser disconnected. If you did not close the browser yourself, browser performance or network issues may be at fault.',
    [types_1.RUNTIME_ERRORS.cannotRunAgainstDisconnectedBrowsers]: 'The following browsers disconnected: {userAgents}. Cannot run further tests.',
    [types_1.RUNTIME_ERRORS.testRunRequestInDisconnectedBrowser]: '"{browser}" disconnected during test execution.',
    [types_1.RUNTIME_ERRORS.cannotEstablishBrowserConnection]: 'Cannot establish one or more browser connections.',
    [types_1.RUNTIME_ERRORS.cannotFindBrowser]: 'Cannot find the browser. "{browser}" is neither a known browser alias, nor a path to an executable file.',
    [types_1.RUNTIME_ERRORS.browserProviderNotFound]: 'Cannot find the "{providerName}" browser provider.',
    [types_1.RUNTIME_ERRORS.browserNotSet]: 'You have not specified a browser.',
    [types_1.RUNTIME_ERRORS.testFilesNotFound]: 'Could not find test files at the following location: "{cwd}".\n' +
        'Check patterns for errors:\n\n' +
        '{sourceList}\n\n' +
        'or launch TestCafe from a different directory.\n' +
        `For more information on how to specify test locations, see ${DOCUMENTATION_LINKS.TEST_SOURCE_PARAMETER}.`,
    [types_1.RUNTIME_ERRORS.noTestsToRun]: "Source files do not contain valid 'fixture' and 'test' declarations.",
    [types_1.RUNTIME_ERRORS.noTestsToRunDueFiltering]: 'No tests match your filter.\n' +
        `See ${DOCUMENTATION_LINKS.FILTER_SETTINGS}.`,
    [types_1.RUNTIME_ERRORS.cannotFindReporterForAlias]: 'The "{name}" reporter does not exist. Check the reporter parameter for errors.',
    [types_1.RUNTIME_ERRORS.multipleSameStreamReporters]: 'Reporters cannot share output streams. The following reporters interfere with one another: "{reporters}".',
    [types_1.RUNTIME_ERRORS.optionValueIsNotValidRegExp]: 'The "{optionName}" option does not contain a valid regular expression.',
    [types_1.RUNTIME_ERRORS.optionValueIsNotValidKeyValue]: 'The "{optionName}" option does not contain a valid key-value pair.',
    [types_1.RUNTIME_ERRORS.invalidQuarantineOption]: 'The "{optionName}" option does not exist. Specify "attemptLimit" and "successThreshold" to configure quarantine mode.',
    [types_1.RUNTIME_ERRORS.invalidQuarantineParametersRatio]: 'The value of "attemptLimit" ({attemptLimit}) should be greater then the value of "successThreshold" ({successThreshold}).',
    [types_1.RUNTIME_ERRORS.invalidAttemptLimitValue]: 'The "{attemptLimit}" parameter only accepts values of {MIN_ATTEMPT_LIMIT} and up.',
    [types_1.RUNTIME_ERRORS.invalidSuccessThresholdValue]: 'The "{successThreshold}" parameter only accepts values of {MIN_SUCCESS_THRESHOLD} and up.',
    [types_1.RUNTIME_ERRORS.invalidSpeedValue]: 'Speed should be a number between 0.01 and 1.',
    [types_1.RUNTIME_ERRORS.invalidConcurrencyFactor]: 'The concurrency factor should be an integer greater than or equal to 1.',
    [types_1.RUNTIME_ERRORS.cannotDivideRemotesCountByConcurrency]: 'The number of remote browsers should be divisible by the concurrency factor.',
    [types_1.RUNTIME_ERRORS.cannotSetConcurrencyWithCDPPort]: 'The value of the "concurrency" option includes the CDP port.',
    [types_1.RUNTIME_ERRORS.portsOptionRequiresTwoNumbers]: 'The "--ports" argument accepts two values at a time.',
    [types_1.RUNTIME_ERRORS.portIsNotFree]: 'Port {portNum} is occupied by another process.',
    [types_1.RUNTIME_ERRORS.invalidHostname]: 'Cannot resolve hostname "{hostname}".',
    [types_1.RUNTIME_ERRORS.cannotFindSpecifiedTestSource]: 'Cannot find a test file at "{path}".',
    [types_1.RUNTIME_ERRORS.clientFunctionCodeIsNotAFunction]: 'Cannot initialize a ClientFunction because {#instantiationCallsiteName} is {type}, and not a function.',
    [types_1.RUNTIME_ERRORS.selectorInitializedWithWrongType]: 'Cannot initialize a Selector because {#instantiationCallsiteName} is {type}, and not one of the following: a CSS selector string, a Selector object, a node snapshot, a function, or a Promise returned by a Selector.',
    [types_1.RUNTIME_ERRORS.clientFunctionCannotResolveTestRun]: "{#instantiationCallsiteName} cannot implicitly resolve the test run in context of which it should be executed. If you need to call {#instantiationCallsiteName} from the Node.js API callback, pass the test controller manually via {#instantiationCallsiteName}'s `.with({ boundTestRun: t })` method first. Note that you cannot execute {#instantiationCallsiteName} outside the test code.",
    [types_1.RUNTIME_ERRORS.requestCannotResolveTestRun]: "'request' cannot implicitly resolve the test run in context of which it should be executed. Note that you cannot execute 'request' in the experimental debug mode.",
    [types_1.RUNTIME_ERRORS.regeneratorInClientFunctionCode]: `{#instantiationCallsiteName} code, arguments or dependencies cannot contain generators or "async/await" syntax (use Promises instead).`,
    [types_1.RUNTIME_ERRORS.invalidClientFunctionTestRunBinding]: 'Cannot resolve the "boundTestRun" option because its value is not a test controller.',
    [types_1.RUNTIME_ERRORS.invalidValueType]: '{smthg} ({actual}) is not of expected type ({type}).',
    [types_1.RUNTIME_ERRORS.unsupportedUrlProtocol]: 'Invalid {what}: "{url}". TestCafe cannot execute the test because the {what} includes the {protocol} protocol. TestCafe supports the following protocols: http://, https:// and file://.',
    [types_1.RUNTIME_ERRORS.testControllerProxyCannotResolveTestRun]: `Cannot implicitly resolve the test run in the context of which the test controller action should be executed. Use test function's 't' argument instead.`,
    [types_1.RUNTIME_ERRORS.timeLimitedPromiseTimeoutExpired]: 'A Promise timed out.',
    [types_1.RUNTIME_ERRORS.cannotSetVideoOptionsWithoutBaseVideoPathSpecified]: 'You cannot manage advanced video parameters when the video recording capability is off. Specify the root storage folder for video content to enable video recording.',
    [types_1.RUNTIME_ERRORS.multipleAPIMethodCallForbidden]: 'You cannot call the "{methodName}" method more than once. Specify an array of parameters instead.',
    [types_1.RUNTIME_ERRORS.invalidReporterOutput]: "Specify a file name or a writable stream as the reporter's output target.",
    [types_1.RUNTIME_ERRORS.cannotReadSSLCertFile]: 'Unable to read the file referenced by the "{option}" ssl option ("{path}"). Error details:\n' +
        '\n' +
        '{err}',
    [types_1.RUNTIME_ERRORS.cannotPrepareTestsDueToError]: 'Cannot prepare tests due to the following error:\n' +
        '\n' +
        '{errMessage}',
    [types_1.RUNTIME_ERRORS.cannotParseRawFile]: 'Cannot parse a raw test file at "{path}" due to the following error:\n' +
        '\n' +
        '{errMessage}',
    [types_1.RUNTIME_ERRORS.testedAppFailedWithError]: 'The web application failed with the following error:\n' +
        '\n' +
        '{errMessage}',
    [types_1.RUNTIME_ERRORS.unableToOpenBrowser]: 'Unable to open the "{alias}" browser due to the following error:\n' +
        '\n' +
        '{errMessage}',
    [types_1.RUNTIME_ERRORS.requestHookConfigureAPIError]: 'Attempt to configure a request hook resulted in the following error:\n' +
        '\n' +
        '{requestHookName}: {errMsg}',
    [types_1.RUNTIME_ERRORS.forbiddenCharatersInScreenshotPath]: 'There are forbidden characters in the "{screenshotPath}" {screenshotPathType}:\n' +
        ' {forbiddenCharsDescription}',
    [types_1.RUNTIME_ERRORS.cannotFindFFMPEG]: 'TestCafe cannot record videos because it cannot locate the FFmpeg executable. Try one of the following solutions:\n' +
        '\n' +
        '* add the path of the FFmpeg installation directory to the PATH environment variable,\n' +
        '* specify the path of the FFmpeg executable in the FFMPEG_PATH environment variable or the ffmpegPath option,\n' +
        '* install the @ffmpeg-installer/ffmpeg npm package.',
    [types_1.RUNTIME_ERRORS.cannotFindTypescriptConfigurationFile]: '"{filePath}" is not a valid TypeScript configuration file.',
    [types_1.RUNTIME_ERRORS.clientScriptInitializerIsNotSpecified]: 'Initialize your client script with one of the following: a JavaScript script, a JavaScript file path, or the name of a JavaScript module.',
    [types_1.RUNTIME_ERRORS.clientScriptBasePathIsNotSpecified]: 'Specify the base path for the client script file.',
    [types_1.RUNTIME_ERRORS.clientScriptInitializerMultipleContentSources]: 'Client scripts can only have one initializer: JavaScript code, a JavaScript file path, or the name of a JavaScript module.',
    [types_1.RUNTIME_ERRORS.cannotLoadClientScriptFromPath]: 'Cannot load a client script from {path}.\n{errorMessage}',
    [types_1.RUNTIME_ERRORS.clientScriptModuleEntryPointPathCalculationError]: 'A client script tried to load a JavaScript module that TestCafe cannot locate:\n\n{errorMessage}.',
    [types_1.RUNTIME_ERRORS.methodIsNotAvailableForAnIPCHost]: 'This method cannot be called on a service host.',
    [types_1.RUNTIME_ERRORS.tooLargeIPCPayload]: 'The specified payload is too large to form an IPC packet.',
    [types_1.RUNTIME_ERRORS.malformedIPCMessage]: 'Cannot process a malformed IPC message.',
    [types_1.RUNTIME_ERRORS.unexpectedIPCHeadPacket]: 'Cannot create an IPC message due to an unexpected IPC head packet.',
    [types_1.RUNTIME_ERRORS.unexpectedIPCBodyPacket]: 'Cannot create an IPC message due to an unexpected IPC body packet.',
    [types_1.RUNTIME_ERRORS.unexpectedIPCTailPacket]: 'Cannot create an IPC message due to an unexpected IPC tail packet.',
    [types_1.RUNTIME_ERRORS.cannotRunLocalNonHeadlessBrowserWithoutDisplay]: 'Your Linux version does not have a graphic subsystem to run {browserAlias} with a GUI. ' +
        'You can launch the browser in headless mode. ' +
        'If you use a portable browser executable, ' +
        "specify the browser alias before the path instead of the 'path' prefix. " +
        `For more information, see ${DOCUMENTATION_LINKS.HEADLESS_MODE}`,
    [types_1.RUNTIME_ERRORS.uncaughtErrorInReporter]: 'The "{methodName}" method of the "{reporterName}" reporter produced an uncaught error. Error details:\n{originalError}',
    [types_1.RUNTIME_ERRORS.roleInitializedWithRelativeUrl]: 'You cannot specify relative login page URLs in the Role constructor. Use an absolute URL.',
    [types_1.RUNTIME_ERRORS.typeScriptCompilerLoadingError]: 'Cannot load the TypeScript compiler.\n{originErrorMessage}.',
    [types_1.RUNTIME_ERRORS.cannotCustomizeSpecifiedCompilers]: 'You cannot specify options for the {noncustomizableCompilerList} compiler{suffix}.',
    [types_1.RUNTIME_ERRORS.cannotEnableRetryTestPagesOption]: 'Cannot enable the \'retryTestPages\' option. Apply one of the following two solutions:\n' +
        '-- set \'localhost\' as the value of the \'hostname\' option\n' +
        '-- run TestCafe over HTTPS\n',
    [types_1.RUNTIME_ERRORS.browserConnectionError]: '{originErrorMessage}\n{numOfNotOpenedConnection} of {numOfAllConnections} browser connections have not been established:\n{listOfNotOpenedConnections}\n\nHints:\n{listOfHints}',
    [error_hints_1.default.TooHighConcurrencyFactor]: 'The host machine may not be powerful enough to handle the specified concurrency factor ({concurrencyFactor}). ' +
        'Try to decrease the concurrency factor or allocate more computing resources to the host machine.',
    [error_hints_1.default.UseBrowserInitOption]: 'Increase the value of the "browserInitTimeout" option if it is too low (currently: {browserInitTimeoutMsg}). This option determines how long TestCafe waits for browsers to be ready.',
    [error_hints_1.default.RestErrorCauses]: 'The error can also be caused by network issues or remote device failure. Make sure that your network connection is stable and you can reach the remote device.',
    [types_1.RUNTIME_ERRORS.cannotFindTestcafeConfigurationFile]: 'Cannot locate a TestCafe configuration file at {filePath}. Either the file does not exist, or the path is invalid.',
    [types_1.RUNTIME_ERRORS.dashboardTokenInJSON]: 'Insecure token declaration: cannot declare a Dashboard token in a JSON configuration file. Use a JavaScript configuration file, or declare a Dashboard token with one of the following: the CLI, the Test Runner API, the TESTCAFE_DASHBOARD_TOKEN environment variable.',
    [types_1.RUNTIME_ERRORS.relativeBaseUrl]: 'The value of the baseUrl argument cannot be relative: "{baseUrl}"',
    [types_1.RUNTIME_ERRORS.requestUrlInvalidValueError]: 'Requested url isn\'t valid ({actualValue}).',
    [types_1.RUNTIME_ERRORS.requestRuntimeError]: 'The request was interrupted by an error:\n{message}',
    [types_1.RUNTIME_ERRORS.invalidSkipJsErrorsOptionsObjectProperty]: `The "{optionName}" option does not exist. Use the following options to configure skipJsErrors: ${(0, string_1.getConcatenatedValuesString)(Object.keys(skip_js_errors_option_names_1.SKIP_JS_ERRORS_OPTIONS_OBJECT_OPTION_NAMES))}.`,
    [types_1.RUNTIME_ERRORS.invalidSkipJsErrorsCallbackWithOptionsProperty]: `The "{optionName}" option does not exist. Use the following options to configure skipJsErrors callback: ${(0, string_1.getConcatenatedValuesString)(Object.keys(skip_js_errors_option_names_1.SKIP_JS_ERRORS_CALLBACK_WITH_OPTIONS_OPTION_NAMES))}.`,
    [types_1.RUNTIME_ERRORS.invalidCommandInJsonCompiler]: `TestCafe terminated the test run. The "{path}" file contains an unknown Chrome User Flow action "{action}". Remove the action to continue. Refer to the following article for the definitive list of supported Chrome User Flow actions: https://testcafe.io/documentation/403998/guides/experimental-capabilities/chrome-replay-support#supported-replay-actions`,
    [types_1.RUNTIME_ERRORS.invalidCustomActionsOptionType]: `The value of the customActions option does not belong to type Object. Refer to the following article for custom action setup instructions: ${DOCUMENTATION_LINKS.CUSTOM_ACTIONS}`,
    [types_1.RUNTIME_ERRORS.invalidCustomActionType]: `TestCafe cannot parse the "{actionName}" action, because the action definition is invalid. Format the definition in accordance with the custom actions guide: ${DOCUMENTATION_LINKS.CUSTOM_ACTIONS}`,
    [types_1.RUNTIME_ERRORS.cannotImportESMInCommonsJS]: 'Cannot import the {esModule} ECMAScript module from {targetFile}. Use a dynamic import() statement or enable the --esm CLI flag.',
    [types_1.RUNTIME_ERRORS.setNativeAutomationForUnsupportedBrowsers]: 'The "{browser}" do not support the Native Automation mode. Remove the "native automation" option to continue.',
};
module.exports = exports.default;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVtcGxhdGVzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2Vycm9ycy9ydW50aW1lL3RlbXBsYXRlcy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsZ0VBQWdFO0FBQ2hFLGdFQUFnRTtBQUNoRSwrQ0FBK0M7QUFDL0MsZ0VBQWdFOzs7OztBQUVoRSxvQ0FBMEM7QUFDMUMsdUZBQThFO0FBQzlFLCtDQUFpRTtBQUNqRSxpR0FBZ0s7QUFFaEssTUFBTSxtQkFBbUIsR0FBRztJQUN4QixxQkFBcUIsRUFBRSxpR0FBaUc7SUFDeEgsZUFBZSxFQUFRLDhFQUE4RTtJQUNyRyxhQUFhLEVBQVUseUZBQXlGO0lBQ2hILGNBQWMsRUFBUyxxRkFBcUY7Q0FDL0csQ0FBQztBQUVGLGtCQUFlO0lBQ1gsQ0FBQyxzQkFBYyxDQUFDLG1DQUFtQyxDQUFDLEVBQUcseUVBQXlFO0lBQ2hJLENBQUMsc0JBQWMsQ0FBQyxvQ0FBb0MsQ0FBQyxFQUFFLHVGQUF1RjtJQUM5SSxDQUFDLHNCQUFjLENBQUMsbUJBQW1CLENBQUMsRUFBbUIseUlBQXlJO0lBQ2hNLENBQUMsc0JBQWMsQ0FBQyxvQ0FBb0MsQ0FBQyxFQUFFLDhFQUE4RTtJQUNySSxDQUFDLHNCQUFjLENBQUMsbUNBQW1DLENBQUMsRUFBRyxpREFBaUQ7SUFDeEcsQ0FBQyxzQkFBYyxDQUFDLGdDQUFnQyxDQUFDLEVBQU0sbURBQW1EO0lBQzFHLENBQUMsc0JBQWMsQ0FBQyxpQkFBaUIsQ0FBQyxFQUFxQiwwR0FBMEc7SUFDakssQ0FBQyxzQkFBYyxDQUFDLHVCQUF1QixDQUFDLEVBQWUsb0RBQW9EO0lBQzNHLENBQUMsc0JBQWMsQ0FBQyxhQUFhLENBQUMsRUFBeUIsbUNBQW1DO0lBQzFGLENBQUMsc0JBQWMsQ0FBQyxpQkFBaUIsQ0FBQyxFQUFxQixpRUFBaUU7UUFDakUsZ0NBQWdDO1FBQ2hDLGtCQUFrQjtRQUNsQixrREFBa0Q7UUFDbEQsOERBQThELG1CQUFtQixDQUFD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SUFBSSxDQUFDLCtFQUFpRCxDQUFDLENBQUMsR0FBRztJQUMxUSxDQUFDLHNCQUFjLENBQUMsNEJBQTRCLENBQUMsRUFBb0IsbVdBQW1XO0lBQ3BhLENBQUMsc0JBQWMsQ0FBQyw4QkFBOEIsQ0FBQyxFQUFrQiw4SUFBK0ksbUJBQW1CLENBQUMsY0FBZSxFQUFFO0lBQ3JQLENBQUMsc0JBQWMsQ0FBQyx1QkFBdUIsQ0FBQyxFQUF5QixpS0FBa0ssbUJBQW1CLENBQUMsY0FBZSxFQUFFO0lBQ3hRLENBQUMsc0JBQWMsQ0FBQywwQkFBMEIsQ0FBQyxFQUFzQixrSUFBa0k7SUFDbk0sQ0FBQyxzQkFBYyxDQUFDLHlDQUF5QyxDQUFDLEVBQU8sK0dBQStHO0NBQ25MLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBXQVJOSU5HOiB0aGlzIGZpbGUgaXMgdXNlZCBieSBib3RoIHRoZSBjbGllbnQgYW5kIHRoZSBzZXJ2ZXIuXG4vLyBEbyBub3QgdXNlIGFueSBicm93c2VyIG9yIG5vZGUtc3BlY2lmaWMgQVBJIVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5pbXBvcnQgeyBSVU5USU1FX0VSUk9SUyB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCBCcm93c2VyQ29ubmVjdGlvbkVycm9ySGludCBmcm9tICcuLi8uLi9icm93c2VyL2Nvbm5lY3Rpb24vZXJyb3ItaGludHMnO1xuaW1wb3J0IHsgZ2V0Q29uY2F0ZW5hdGVkVmFsdWVzU3RyaW5nIH0gZnJvbSAnLi4vLi4vdXRpbHMvc3RyaW5nJztcbmltcG9ydCB7IFNLSVBfSlNfRVJST1JTX09QVElPTlNfT0JKRUNUX09QVElPTl9OQU1FUywgU0tJUF9KU19FUlJPUlNfQ0FMTEJBQ0tfV0lUSF9PUFRJT05TX09QVElPTl9OQU1FUyB9IGZyb20gJy4uLy4uL2NvbmZpZ3VyYXRpb24vc2tpcC1qcy1lcnJvcnMtb3B0aW9uLW5hbWVzJztcblxuY29uc3QgRE9DVU1FTlRBVElPTl9MSU5LUyA9IHtcbiAgICBURVNUX1NPVVJDRV9QQVJBTUVURVI6ICdodHRwczovL3Rlc3RjYWZlLmlvL2RvY3VtZW50YXRpb24vNDAyNjM5L3JlZmVyZW5jZS9jb21tYW5kLWxpbmUtaW50ZXJmYWNlI2ZpbGUtcGF0aGdsb2ItcGF0dGVybicsXG4gICAgRklMVEVSX1NFVFRJTkdTOiAgICAgICAnaHR0cHM6Ly90ZXN0Y2FmZS5pby9kb2N1bWVudGF0aW9uLzQwMjYzOC9yZWZlcmVuY2UvY29uZmlndXJhdGlvbi1maWxlI2ZpbHRlcicsXG4gICAgSEVBRExFU1NfTU9ERTogICAgICAgICAnaHR0cHM6Ly90ZXN0Y2FmZS5pby9kb2N1bWVudGF0aW9uLzQwMjgyOC9ndWlkZXMvY29uY2VwdHMvYnJvd3NlcnMjdGVzdC1pbi1oZWFkbGVzcy1tb2RlJyxcbiAgICBDVVNUT01fQUNUSU9OUzogICAgICAgICdodHRwczovL3Rlc3RjYWZlLmlvL2RvY3VtZW50YXRpb24vNDA0MTUwL2d1aWRlcy9hZHZhbmNlZC1ndWlkZXMvY3VzdG9tLXRlc3QtYWN0aW9ucycsXG59O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgW1JVTlRJTUVfRVJST1JTLmNhbm5vdENyZWF0ZU11bHRpcGxlTGl2ZU1vZGVSdW5uZXJzXTogICdDYW5ub3QgbGF1bmNoIG11bHRpcGxlIGxpdmUgbW9kZSBpbnN0YW5jZXMgb2YgdGhlIFRlc3RDYWZlIHRlc3QgcnVubmVyLicsXG4gICAgW1JVTlRJTUVfRVJST1JTLmNhbm5vdFJ1bkxpdmVNb2RlUnVubmVyTXVsdGlwbGVUaW1lc106ICdDYW5ub3QgbGF1bmNoIHRoZSBzYW1lIGxpdmUgbW9kZSBpbnN0YW5jZSBvZiB0aGUgVGVzdENhZmUgdGVzdCBydW5uZXIgbXVsdGlwbGUgdGltZXMuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMuYnJvd3NlckRpc2Nvbm5lY3RlZF06ICAgICAgICAgICAgICAgICAgJ1RoZSB7dXNlckFnZW50fSBicm93c2VyIGRpc2Nvbm5lY3RlZC4gSWYgeW91IGRpZCBub3QgY2xvc2UgdGhlIGJyb3dzZXIgeW91cnNlbGYsIGJyb3dzZXIgcGVyZm9ybWFuY2Ugb3IgbmV0d29yayBpc3N1ZXMgbWF5IGJlIGF0IGZhdWx0LicsXG4gICAgW1JVTlRJTUVfRVJST1JTLmNhbm5vdFJ1bkFnYWluc3REaXNjb25uZWN0ZWRCcm93c2Vyc106ICdUaGUgZm9sbG93aW5nIGJyb3dzZXJzIGRpc2Nvbm5lY3RlZDoge3VzZXJBZ2VudHN9LiBDYW5ub3QgcnVuIGZ1cnRoZXIgdGVzdHMuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMudGVzdFJ1blJlcXVlc3RJbkRpc2Nvbm5lY3RlZEJyb3dzZXJdOiAgJ1wie2Jyb3dzZXJ9XCIgZGlzY29ubmVjdGVkIGR1cmluZyB0ZXN0IGV4ZWN1dGlvbi4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5jYW5ub3RFc3RhYmxpc2hCcm93c2VyQ29ubmVjdGlvbl06ICAgICAnQ2Fubm90IGVzdGFibGlzaCBvbmUgb3IgbW9yZSBicm93c2VyIGNvbm5lY3Rpb25zLicsXG4gICAgW1JVTlRJTUVfRVJST1JTLmNhbm5vdEZpbmRCcm93c2VyXTogICAgICAgICAgICAgICAgICAgICdDYW5ub3QgZmluZCB0aGUgYnJvd3Nlci4gXCJ7YnJvd3Nlcn1cIiBpcyBuZWl0aGVyIGEga25vd24gYnJvd3NlciBhbGlhcywgbm9yIGEgcGF0aCB0byBhbiBleGVjdXRhYmxlIGZpbGUuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMuYnJvd3NlclByb3ZpZGVyTm90Rm91bmRdOiAgICAgICAgICAgICAgJ0Nhbm5vdCBmaW5kIHRoZSBcIntwcm92aWRlck5hbWV9XCIgYnJvd3NlciBwcm92aWRlci4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5icm93c2VyTm90U2V0XTogICAgICAgICAgICAgICAgICAgICAgICAnWW91IGhhdmUgbm90IHNwZWNpZmllZCBhIGJyb3dzZXIuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMudGVzdEZpbGVzTm90Rm91bmRdOiAgICAgICAgICAgICAgICAgICAgJ0NvdWxkIG5vdCBmaW5kIHRlc3QgZmlsZXMgYXQgdGhlIGZvbGxvd2luZyBsb2NhdGlvbjogXCJ7Y3dkfVwiLlxcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnQ2hlY2sgcGF0dGVybnMgZm9yIGVycm9yczpcXG5cXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3tzb3VyY2VMaXN0fVxcblxcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb3IgbGF1bmNoIFRlc3RDYWZlIGZyb20gYSBkaWZmZXJlbnQgZGlyZWN0b3J5LlxcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gaG93IHRvIHNwZWNpZnkgdGVzdCBsb2NhdGlvbnMsIHNlZSAke0RPQ1VNRU5UQVRJT05fTElOS1MuVEVTVF9TT1VSQ0VfUEFSQU1FVEVSfS5gLFxuXG4gICAgW1JVTlRJTUVfRVJST1JTLm5vVGVzdHNUb1J1bl06IFwiU291cmNlIGZpbGVzIGRvIG5vdCBjb250YWluIHZhbGlkICdmaXh0dXJlJyBhbmQgJ3Rlc3QnIGRlY2xhcmF0aW9ucy5cIixcblxuICAgIFtSVU5USU1FX0VSUk9SUy5ub1Rlc3RzVG9SdW5EdWVGaWx0ZXJpbmddOiAnTm8gdGVzdHMgbWF0Y2ggeW91ciBmaWx0ZXIuXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBTZWUgJHtET0NVTUVOVEFUSU9OX0xJTktTLkZJTFRFUl9TRVRUSU5HU30uYCxcblxuICAgIFtSVU5USU1FX0VSUk9SUy5jYW5ub3RGaW5kUmVwb3J0ZXJGb3JBbGlhc106ICAgICAgICAgICAgICAgICAgICAgICAgICdUaGUgXCJ7bmFtZX1cIiByZXBvcnRlciBkb2VzIG5vdCBleGlzdC4gQ2hlY2sgdGhlIHJlcG9ydGVyIHBhcmFtZXRlciBmb3IgZXJyb3JzLicsXG4gICAgW1JVTlRJTUVfRVJST1JTLm11bHRpcGxlU2FtZVN0cmVhbVJlcG9ydGVyc106ICAgICAgICAgICAgICAgICAgICAgICAgJ1JlcG9ydGVycyBjYW5ub3Qgc2hhcmUgb3V0cHV0IHN0cmVhbXMuIFRoZSBmb2xsb3dpbmcgcmVwb3J0ZXJzIGludGVyZmVyZSB3aXRoIG9uZSBhbm90aGVyOiBcIntyZXBvcnRlcnN9XCIuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMub3B0aW9uVmFsdWVJc05vdFZhbGlkUmVnRXhwXTogICAgICAgICAgICAgICAgICAgICAgICAnVGhlIFwie29wdGlvbk5hbWV9XCIgb3B0aW9uIGRvZXMgbm90IGNvbnRhaW4gYSB2YWxpZCByZWd1bGFyIGV4cHJlc3Npb24uJyxcbiAgICBbUlVOVElNRV9FUlJPUlMub3B0aW9uVmFsdWVJc05vdFZhbGlkS2V5VmFsdWVdOiAgICAgICAgICAgICAgICAgICAgICAnVGhlIFwie29wdGlvbk5hbWV9XCIgb3B0aW9uIGRvZXMgbm90IGNvbnRhaW4gYSB2YWxpZCBrZXktdmFsdWUgcGFpci4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5pbnZhbGlkUXVhcmFudGluZU9wdGlvbl06ICAgICAgICAgICAgICAgICAgICAgICAgICAgICdUaGUgXCJ7b3B0aW9uTmFtZX1cIiBvcHRpb24gZG9lcyBub3QgZXhpc3QuIFNwZWNpZnkgXCJhdHRlbXB0TGltaXRcIiBhbmQgXCJzdWNjZXNzVGhyZXNob2xkXCIgdG8gY29uZmlndXJlIHF1YXJhbnRpbmUgbW9kZS4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5pbnZhbGlkUXVhcmFudGluZVBhcmFtZXRlcnNSYXRpb106ICAgICAgICAgICAgICAgICAgICdUaGUgdmFsdWUgb2YgXCJhdHRlbXB0TGltaXRcIiAoe2F0dGVtcHRMaW1pdH0pIHNob3VsZCBiZSBncmVhdGVyIHRoZW4gdGhlIHZhbHVlIG9mIFwic3VjY2Vzc1RocmVzaG9sZFwiICh7c3VjY2Vzc1RocmVzaG9sZH0pLicsXG4gICAgW1JVTlRJTUVfRVJST1JTLmludmFsaWRBdHRlbXB0TGltaXRWYWx1ZV06ICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1RoZSBcInthdHRlbXB0TGltaXR9XCIgcGFyYW1ldGVyIG9ubHkgYWNjZXB0cyB2YWx1ZXMgb2Yge01JTl9BVFRFTVBUX0xJTUlUfSBhbmQgdXAuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMuaW52YWxpZFN1Y2Nlc3NUaHJlc2hvbGRWYWx1ZV06ICAgICAgICAgICAgICAgICAgICAgICAnVGhlIFwie3N1Y2Nlc3NUaHJlc2hvbGR9XCIgcGFyYW1ldGVyIG9ubHkgYWNjZXB0cyB2YWx1ZXMgb2Yge01JTl9TVUNDRVNTX1RIUkVTSE9MRH0gYW5kIHVwLicsXG4gICAgW1JVTlRJTUVfRVJST1JTLmludmFsaWRTcGVlZFZhbHVlXTogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1NwZWVkIHNob3VsZCBiZSBhIG51bWJlciBiZXR3ZWVuIDAuMDEgYW5kIDEuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMuaW52YWxpZENvbmN1cnJlbmN5RmFjdG9yXTogICAgICAgICAgICAgICAgICAgICAgICAgICAnVGhlIGNvbmN1cnJlbmN5IGZhY3RvciBzaG91bGQgYmUgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMS4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5jYW5ub3REaXZpZGVSZW1vdGVzQ291bnRCeUNvbmN1cnJlbmN5XTogICAgICAgICAgICAgICdUaGUgbnVtYmVyIG9mIHJlbW90ZSBicm93c2VycyBzaG91bGQgYmUgZGl2aXNpYmxlIGJ5IHRoZSBjb25jdXJyZW5jeSBmYWN0b3IuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMuY2Fubm90U2V0Q29uY3VycmVuY3lXaXRoQ0RQUG9ydF06ICAgICAgICAgICAgICAgICAgICAnVGhlIHZhbHVlIG9mIHRoZSBcImNvbmN1cnJlbmN5XCIgb3B0aW9uIGluY2x1ZGVzIHRoZSBDRFAgcG9ydC4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5wb3J0c09wdGlvblJlcXVpcmVzVHdvTnVtYmVyc106ICAgICAgICAgICAgICAgICAgICAgICdUaGUgXCItLXBvcnRzXCIgYXJndW1lbnQgYWNjZXB0cyB0d28gdmFsdWVzIGF0IGEgdGltZS4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5wb3J0SXNOb3RGcmVlXTogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdQb3J0IHtwb3J0TnVtfSBpcyBvY2N1cGllZCBieSBhbm90aGVyIHByb2Nlc3MuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMuaW52YWxpZEhvc3RuYW1lXTogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnQ2Fubm90IHJlc29sdmUgaG9zdG5hbWUgXCJ7aG9zdG5hbWV9XCIuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMuY2Fubm90RmluZFNwZWNpZmllZFRlc3RTb3VyY2VdOiAgICAgICAgICAgICAgICAgICAgICAnQ2Fubm90IGZpbmQgYSB0ZXN0IGZpbGUgYXQgXCJ7cGF0aH1cIi4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5jbGllbnRGdW5jdGlvbkNvZGVJc05vdEFGdW5jdGlvbl06ICAgICAgICAgICAgICAgICAgICdDYW5ub3QgaW5pdGlhbGl6ZSBhIENsaWVudEZ1bmN0aW9uIGJlY2F1c2UgeyNpbnN0YW50aWF0aW9uQ2FsbHNpdGVOYW1lfSBpcyB7dHlwZX0sIGFuZCBub3QgYSBmdW5jdGlvbi4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5zZWxlY3RvckluaXRpYWxpemVkV2l0aFdyb25nVHlwZV06ICAgICAgICAgICAgICAgICAgICdDYW5ub3QgaW5pdGlhbGl6ZSBhIFNlbGVjdG9yIGJlY2F1c2UgeyNpbnN0YW50aWF0aW9uQ2FsbHNpdGVOYW1lfSBpcyB7dHlwZX0sIGFuZCBub3Qgb25lIG9mIHRoZSBmb2xsb3dpbmc6IGEgQ1NTIHNlbGVjdG9yIHN0cmluZywgYSBTZWxlY3RvciBvYmplY3QsIGEgbm9kZSBzbmFwc2hvdCwgYSBmdW5jdGlvbiwgb3IgYSBQcm9taXNlIHJldHVybmVkIGJ5IGEgU2VsZWN0b3IuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMuY2xpZW50RnVuY3Rpb25DYW5ub3RSZXNvbHZlVGVzdFJ1bl06ICAgICAgICAgICAgICAgICBcInsjaW5zdGFudGlhdGlvbkNhbGxzaXRlTmFtZX0gY2Fubm90IGltcGxpY2l0bHkgcmVzb2x2ZSB0aGUgdGVzdCBydW4gaW4gY29udGV4dCBvZiB3aGljaCBpdCBzaG91bGQgYmUgZXhlY3V0ZWQuIElmIHlvdSBuZWVkIHRvIGNhbGwgeyNpbnN0YW50aWF0aW9uQ2FsbHNpdGVOYW1lfSBmcm9tIHRoZSBOb2RlLmpzIEFQSSBjYWxsYmFjaywgcGFzcyB0aGUgdGVzdCBjb250cm9sbGVyIG1hbnVhbGx5IHZpYSB7I2luc3RhbnRpYXRpb25DYWxsc2l0ZU5hbWV9J3MgYC53aXRoKHsgYm91bmRUZXN0UnVuOiB0IH0pYCBtZXRob2QgZmlyc3QuIE5vdGUgdGhhdCB5b3UgY2Fubm90IGV4ZWN1dGUgeyNpbnN0YW50aWF0aW9uQ2FsbHNpdGVOYW1lfSBvdXRzaWRlIHRoZSB0ZXN0IGNvZGUuXCIsXG4gICAgW1JVTlRJTUVfRVJST1JTLnJlcXVlc3RDYW5ub3RSZXNvbHZlVGVzdFJ1bl06ICAgICAgICAgICAgICAgICAgICAgICAgXCIncmVxdWVzdCcgY2Fubm90IGltcGxpY2l0bHkgcmVzb2x2ZSB0aGUgdGVzdCBydW4gaW4gY29udGV4dCBvZiB3aGljaCBpdCBzaG91bGQgYmUgZXhlY3V0ZWQuIE5vdGUgdGhhdCB5b3UgY2Fubm90IGV4ZWN1dGUgJ3JlcXVlc3QnIGluIHRoZSBleHBlcmltZW50YWwgZGVidWcgbW9kZS5cIixcbiAgICBbUlVOVElNRV9FUlJPUlMucmVnZW5lcmF0b3JJbkNsaWVudEZ1bmN0aW9uQ29kZV06ICAgICAgICAgICAgICAgICAgICBgeyNpbnN0YW50aWF0aW9uQ2FsbHNpdGVOYW1lfSBjb2RlLCBhcmd1bWVudHMgb3IgZGVwZW5kZW5jaWVzIGNhbm5vdCBjb250YWluIGdlbmVyYXRvcnMgb3IgXCJhc3luYy9hd2FpdFwiIHN5bnRheCAodXNlIFByb21pc2VzIGluc3RlYWQpLmAsXG4gICAgW1JVTlRJTUVfRVJST1JTLmludmFsaWRDbGllbnRGdW5jdGlvblRlc3RSdW5CaW5kaW5nXTogICAgICAgICAgICAgICAgJ0Nhbm5vdCByZXNvbHZlIHRoZSBcImJvdW5kVGVzdFJ1blwiIG9wdGlvbiBiZWNhdXNlIGl0cyB2YWx1ZSBpcyBub3QgYSB0ZXN0IGNvbnRyb2xsZXIuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMuaW52YWxpZFZhbHVlVHlwZV06ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAne3NtdGhnfSAoe2FjdHVhbH0pIGlzIG5vdCBvZiBleHBlY3RlZCB0eXBlICh7dHlwZX0pLicsXG4gICAgW1JVTlRJTUVfRVJST1JTLnVuc3VwcG9ydGVkVXJsUHJvdG9jb2xdOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0ludmFsaWQge3doYXR9OiBcInt1cmx9XCIuIFRlc3RDYWZlIGNhbm5vdCBleGVjdXRlIHRoZSB0ZXN0IGJlY2F1c2UgdGhlIHt3aGF0fSBpbmNsdWRlcyB0aGUge3Byb3RvY29sfSBwcm90b2NvbC4gVGVzdENhZmUgc3VwcG9ydHMgdGhlIGZvbGxvd2luZyBwcm90b2NvbHM6IGh0dHA6Ly8sIGh0dHBzOi8vIGFuZCBmaWxlOi8vLicsXG4gICAgW1JVTlRJTUVfRVJST1JTLnRlc3RDb250cm9sbGVyUHJveHlDYW5ub3RSZXNvbHZlVGVzdFJ1bl06ICAgICAgICAgICAgYENhbm5vdCBpbXBsaWNpdGx5IHJlc29sdmUgdGhlIHRlc3QgcnVuIGluIHRoZSBjb250ZXh0IG9mIHdoaWNoIHRoZSB0ZXN0IGNvbnRyb2xsZXIgYWN0aW9uIHNob3VsZCBiZSBleGVjdXRlZC4gVXNlIHRlc3QgZnVuY3Rpb24ncyAndCcgYXJndW1lbnQgaW5zdGVhZC5gLFxuICAgIFtSVU5USU1FX0VSUk9SUy50aW1lTGltaXRlZFByb21pc2VUaW1lb3V0RXhwaXJlZF06ICAgICAgICAgICAgICAgICAgICdBIFByb21pc2UgdGltZWQgb3V0LicsXG4gICAgW1JVTlRJTUVfRVJST1JTLmNhbm5vdFNldFZpZGVvT3B0aW9uc1dpdGhvdXRCYXNlVmlkZW9QYXRoU3BlY2lmaWVkXTogJ1lvdSBjYW5ub3QgbWFuYWdlIGFkdmFuY2VkIHZpZGVvIHBhcmFtZXRlcnMgd2hlbiB0aGUgdmlkZW8gcmVjb3JkaW5nIGNhcGFiaWxpdHkgaXMgb2ZmLiBTcGVjaWZ5IHRoZSByb290IHN0b3JhZ2UgZm9sZGVyIGZvciB2aWRlbyBjb250ZW50IHRvIGVuYWJsZSB2aWRlbyByZWNvcmRpbmcuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMubXVsdGlwbGVBUElNZXRob2RDYWxsRm9yYmlkZGVuXTogICAgICAgICAgICAgICAgICAgICAnWW91IGNhbm5vdCBjYWxsIHRoZSBcInttZXRob2ROYW1lfVwiIG1ldGhvZCBtb3JlIHRoYW4gb25jZS4gU3BlY2lmeSBhbiBhcnJheSBvZiBwYXJhbWV0ZXJzIGluc3RlYWQuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMuaW52YWxpZFJlcG9ydGVyT3V0cHV0XTogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlNwZWNpZnkgYSBmaWxlIG5hbWUgb3IgYSB3cml0YWJsZSBzdHJlYW0gYXMgdGhlIHJlcG9ydGVyJ3Mgb3V0cHV0IHRhcmdldC5cIixcbiAgICBbUlVOVElNRV9FUlJPUlMuY2Fubm90UmVhZFNTTENlcnRGaWxlXTogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnVW5hYmxlIHRvIHJlYWQgdGhlIGZpbGUgcmVmZXJlbmNlZCBieSB0aGUgXCJ7b3B0aW9ufVwiIHNzbCBvcHRpb24gKFwie3BhdGh9XCIpLiBFcnJvciBkZXRhaWxzOlxcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAne2Vycn0nLFxuXG4gICAgW1JVTlRJTUVfRVJST1JTLmNhbm5vdFByZXBhcmVUZXN0c0R1ZVRvRXJyb3JdOiAnQ2Fubm90IHByZXBhcmUgdGVzdHMgZHVlIHRvIHRoZSBmb2xsb3dpbmcgZXJyb3I6XFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAne2Vyck1lc3NhZ2V9JyxcblxuICAgIFtSVU5USU1FX0VSUk9SUy5jYW5ub3RQYXJzZVJhd0ZpbGVdOiAnQ2Fubm90IHBhcnNlIGEgcmF3IHRlc3QgZmlsZSBhdCBcIntwYXRofVwiIGR1ZSB0byB0aGUgZm9sbG93aW5nIGVycm9yOlxcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd7ZXJyTWVzc2FnZX0nLFxuXG4gICAgW1JVTlRJTUVfRVJST1JTLnRlc3RlZEFwcEZhaWxlZFdpdGhFcnJvcl06ICdUaGUgd2ViIGFwcGxpY2F0aW9uIGZhaWxlZCB3aXRoIHRoZSBmb2xsb3dpbmcgZXJyb3I6XFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3tlcnJNZXNzYWdlfScsXG5cbiAgICBbUlVOVElNRV9FUlJPUlMudW5hYmxlVG9PcGVuQnJvd3Nlcl06ICdVbmFibGUgdG8gb3BlbiB0aGUgXCJ7YWxpYXN9XCIgYnJvd3NlciBkdWUgdG8gdGhlIGZvbGxvd2luZyBlcnJvcjpcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd7ZXJyTWVzc2FnZX0nLFxuXG4gICAgW1JVTlRJTUVfRVJST1JTLnJlcXVlc3RIb29rQ29uZmlndXJlQVBJRXJyb3JdOiAnQXR0ZW1wdCB0byBjb25maWd1cmUgYSByZXF1ZXN0IGhvb2sgcmVzdWx0ZWQgaW4gdGhlIGZvbGxvd2luZyBlcnJvcjpcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd7cmVxdWVzdEhvb2tOYW1lfToge2Vyck1zZ30nLFxuXG4gICAgW1JVTlRJTUVfRVJST1JTLmZvcmJpZGRlbkNoYXJhdGVyc0luU2NyZWVuc2hvdFBhdGhdOiAnVGhlcmUgYXJlIGZvcmJpZGRlbiBjaGFyYWN0ZXJzIGluIHRoZSBcIntzY3JlZW5zaG90UGF0aH1cIiB7c2NyZWVuc2hvdFBhdGhUeXBlfTpcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcge2ZvcmJpZGRlbkNoYXJzRGVzY3JpcHRpb259JyxcblxuICAgIFtSVU5USU1FX0VSUk9SUy5jYW5ub3RGaW5kRkZNUEVHXTogJ1Rlc3RDYWZlIGNhbm5vdCByZWNvcmQgdmlkZW9zIGJlY2F1c2UgaXQgY2Fubm90IGxvY2F0ZSB0aGUgRkZtcGVnIGV4ZWN1dGFibGUuIFRyeSBvbmUgb2YgdGhlIGZvbGxvd2luZyBzb2x1dGlvbnM6XFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnKiBhZGQgdGhlIHBhdGggb2YgdGhlIEZGbXBlZyBpbnN0YWxsYXRpb24gZGlyZWN0b3J5IHRvIHRoZSBQQVRIIGVudmlyb25tZW50IHZhcmlhYmxlLFxcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyogc3BlY2lmeSB0aGUgcGF0aCBvZiB0aGUgRkZtcGVnIGV4ZWN1dGFibGUgaW4gdGhlIEZGTVBFR19QQVRIIGVudmlyb25tZW50IHZhcmlhYmxlIG9yIHRoZSBmZm1wZWdQYXRoIG9wdGlvbixcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcqIGluc3RhbGwgdGhlIEBmZm1wZWctaW5zdGFsbGVyL2ZmbXBlZyBucG0gcGFja2FnZS4nLFxuXG4gICAgW1JVTlRJTUVfRVJST1JTLmNhbm5vdEZpbmRUeXBlc2NyaXB0Q29uZmlndXJhdGlvbkZpbGVdOiAgICAgICAgICAgICdcIntmaWxlUGF0aH1cIiBpcyBub3QgYSB2YWxpZCBUeXBlU2NyaXB0IGNvbmZpZ3VyYXRpb24gZmlsZS4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5jbGllbnRTY3JpcHRJbml0aWFsaXplcklzTm90U3BlY2lmaWVkXTogICAgICAgICAgICAnSW5pdGlhbGl6ZSB5b3VyIGNsaWVudCBzY3JpcHQgd2l0aCBvbmUgb2YgdGhlIGZvbGxvd2luZzogYSBKYXZhU2NyaXB0IHNjcmlwdCwgYSBKYXZhU2NyaXB0IGZpbGUgcGF0aCwgb3IgdGhlIG5hbWUgb2YgYSBKYXZhU2NyaXB0IG1vZHVsZS4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5jbGllbnRTY3JpcHRCYXNlUGF0aElzTm90U3BlY2lmaWVkXTogICAgICAgICAgICAgICAnU3BlY2lmeSB0aGUgYmFzZSBwYXRoIGZvciB0aGUgY2xpZW50IHNjcmlwdCBmaWxlLicsXG4gICAgW1JVTlRJTUVfRVJST1JTLmNsaWVudFNjcmlwdEluaXRpYWxpemVyTXVsdGlwbGVDb250ZW50U291cmNlc106ICAgICdDbGllbnQgc2NyaXB0cyBjYW4gb25seSBoYXZlIG9uZSBpbml0aWFsaXplcjogSmF2YVNjcmlwdCBjb2RlLCBhIEphdmFTY3JpcHQgZmlsZSBwYXRoLCBvciB0aGUgbmFtZSBvZiBhIEphdmFTY3JpcHQgbW9kdWxlLicsXG4gICAgW1JVTlRJTUVfRVJST1JTLmNhbm5vdExvYWRDbGllbnRTY3JpcHRGcm9tUGF0aF06ICAgICAgICAgICAgICAgICAgICdDYW5ub3QgbG9hZCBhIGNsaWVudCBzY3JpcHQgZnJvbSB7cGF0aH0uXFxue2Vycm9yTWVzc2FnZX0nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5jbGllbnRTY3JpcHRNb2R1bGVFbnRyeVBvaW50UGF0aENhbGN1bGF0aW9uRXJyb3JdOiAnQSBjbGllbnQgc2NyaXB0IHRyaWVkIHRvIGxvYWQgYSBKYXZhU2NyaXB0IG1vZHVsZSB0aGF0IFRlc3RDYWZlIGNhbm5vdCBsb2NhdGU6XFxuXFxue2Vycm9yTWVzc2FnZX0uJyxcbiAgICBbUlVOVElNRV9FUlJPUlMubWV0aG9kSXNOb3RBdmFpbGFibGVGb3JBbklQQ0hvc3RdOiAgICAgICAgICAgICAgICAgJ1RoaXMgbWV0aG9kIGNhbm5vdCBiZSBjYWxsZWQgb24gYSBzZXJ2aWNlIGhvc3QuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMudG9vTGFyZ2VJUENQYXlsb2FkXTogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1RoZSBzcGVjaWZpZWQgcGF5bG9hZCBpcyB0b28gbGFyZ2UgdG8gZm9ybSBhbiBJUEMgcGFja2V0LicsXG4gICAgW1JVTlRJTUVfRVJST1JTLm1hbGZvcm1lZElQQ01lc3NhZ2VdOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdDYW5ub3QgcHJvY2VzcyBhIG1hbGZvcm1lZCBJUEMgbWVzc2FnZS4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy51bmV4cGVjdGVkSVBDSGVhZFBhY2tldF06ICAgICAgICAgICAgICAgICAgICAgICAgICAnQ2Fubm90IGNyZWF0ZSBhbiBJUEMgbWVzc2FnZSBkdWUgdG8gYW4gdW5leHBlY3RlZCBJUEMgaGVhZCBwYWNrZXQuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMudW5leHBlY3RlZElQQ0JvZHlQYWNrZXRdOiAgICAgICAgICAgICAgICAgICAgICAgICAgJ0Nhbm5vdCBjcmVhdGUgYW4gSVBDIG1lc3NhZ2UgZHVlIHRvIGFuIHVuZXhwZWN0ZWQgSVBDIGJvZHkgcGFja2V0LicsXG4gICAgW1JVTlRJTUVfRVJST1JTLnVuZXhwZWN0ZWRJUENUYWlsUGFja2V0XTogICAgICAgICAgICAgICAgICAgICAgICAgICdDYW5ub3QgY3JlYXRlIGFuIElQQyBtZXNzYWdlIGR1ZSB0byBhbiB1bmV4cGVjdGVkIElQQyB0YWlsIHBhY2tldC4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5jYW5ub3RSdW5Mb2NhbE5vbkhlYWRsZXNzQnJvd3NlcldpdGhvdXREaXNwbGF5XTpcbiAgICAgICAgJ1lvdXIgTGludXggdmVyc2lvbiBkb2VzIG5vdCBoYXZlIGEgZ3JhcGhpYyBzdWJzeXN0ZW0gdG8gcnVuIHticm93c2VyQWxpYXN9IHdpdGggYSBHVUkuICcgK1xuICAgICAgICAnWW91IGNhbiBsYXVuY2ggdGhlIGJyb3dzZXIgaW4gaGVhZGxlc3MgbW9kZS4gJyArXG4gICAgICAgICdJZiB5b3UgdXNlIGEgcG9ydGFibGUgYnJvd3NlciBleGVjdXRhYmxlLCAnICtcbiAgICAgICAgXCJzcGVjaWZ5IHRoZSBicm93c2VyIGFsaWFzIGJlZm9yZSB0aGUgcGF0aCBpbnN0ZWFkIG9mIHRoZSAncGF0aCcgcHJlZml4LiBcIiArXG4gICAgICAgIGBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlICR7RE9DVU1FTlRBVElPTl9MSU5LUy5IRUFETEVTU19NT0RFfWAsXG5cbiAgICBbUlVOVElNRV9FUlJPUlMudW5jYXVnaHRFcnJvckluUmVwb3J0ZXJdOiAgICAgICAgICAgJ1RoZSBcInttZXRob2ROYW1lfVwiIG1ldGhvZCBvZiB0aGUgXCJ7cmVwb3J0ZXJOYW1lfVwiIHJlcG9ydGVyIHByb2R1Y2VkIGFuIHVuY2F1Z2h0IGVycm9yLiBFcnJvciBkZXRhaWxzOlxcbntvcmlnaW5hbEVycm9yfScsXG4gICAgW1JVTlRJTUVfRVJST1JTLnJvbGVJbml0aWFsaXplZFdpdGhSZWxhdGl2ZVVybF06ICAgICdZb3UgY2Fubm90IHNwZWNpZnkgcmVsYXRpdmUgbG9naW4gcGFnZSBVUkxzIGluIHRoZSBSb2xlIGNvbnN0cnVjdG9yLiBVc2UgYW4gYWJzb2x1dGUgVVJMLicsXG4gICAgW1JVTlRJTUVfRVJST1JTLnR5cGVTY3JpcHRDb21waWxlckxvYWRpbmdFcnJvcl06ICAgICdDYW5ub3QgbG9hZCB0aGUgVHlwZVNjcmlwdCBjb21waWxlci5cXG57b3JpZ2luRXJyb3JNZXNzYWdlfS4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5jYW5ub3RDdXN0b21pemVTcGVjaWZpZWRDb21waWxlcnNdOiAnWW91IGNhbm5vdCBzcGVjaWZ5IG9wdGlvbnMgZm9yIHRoZSB7bm9uY3VzdG9taXphYmxlQ29tcGlsZXJMaXN0fSBjb21waWxlcntzdWZmaXh9LicsXG5cbiAgICBbUlVOVElNRV9FUlJPUlMuY2Fubm90RW5hYmxlUmV0cnlUZXN0UGFnZXNPcHRpb25dOlxuICAgICAgICAnQ2Fubm90IGVuYWJsZSB0aGUgXFwncmV0cnlUZXN0UGFnZXNcXCcgb3B0aW9uLiBBcHBseSBvbmUgb2YgdGhlIGZvbGxvd2luZyB0d28gc29sdXRpb25zOlxcbicgK1xuICAgICAgICAnLS0gc2V0IFxcJ2xvY2FsaG9zdFxcJyBhcyB0aGUgdmFsdWUgb2YgdGhlIFxcJ2hvc3RuYW1lXFwnIG9wdGlvblxcbicgK1xuICAgICAgICAnLS0gcnVuIFRlc3RDYWZlIG92ZXIgSFRUUFNcXG4nLFxuXG4gICAgW1JVTlRJTUVfRVJST1JTLmJyb3dzZXJDb25uZWN0aW9uRXJyb3JdOiAgICAgICAgICAgICAgICd7b3JpZ2luRXJyb3JNZXNzYWdlfVxcbntudW1PZk5vdE9wZW5lZENvbm5lY3Rpb259IG9mIHtudW1PZkFsbENvbm5lY3Rpb25zfSBicm93c2VyIGNvbm5lY3Rpb25zIGhhdmUgbm90IGJlZW4gZXN0YWJsaXNoZWQ6XFxue2xpc3RPZk5vdE9wZW5lZENvbm5lY3Rpb25zfVxcblxcbkhpbnRzOlxcbntsaXN0T2ZIaW50c30nLFxuICAgIFtCcm93c2VyQ29ubmVjdGlvbkVycm9ySGludC5Ub29IaWdoQ29uY3VycmVuY3lGYWN0b3JdOiAnVGhlIGhvc3QgbWFjaGluZSBtYXkgbm90IGJlIHBvd2VyZnVsIGVub3VnaCB0byBoYW5kbGUgdGhlIHNwZWNpZmllZCBjb25jdXJyZW5jeSBmYWN0b3IgKHtjb25jdXJyZW5jeUZhY3Rvcn0pLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1RyeSB0byBkZWNyZWFzZSB0aGUgY29uY3VycmVuY3kgZmFjdG9yIG9yIGFsbG9jYXRlIG1vcmUgY29tcHV0aW5nIHJlc291cmNlcyB0byB0aGUgaG9zdCBtYWNoaW5lLicsXG4gICAgW0Jyb3dzZXJDb25uZWN0aW9uRXJyb3JIaW50LlVzZUJyb3dzZXJJbml0T3B0aW9uXTogICAgICAgICAgICAgICAnSW5jcmVhc2UgdGhlIHZhbHVlIG9mIHRoZSBcImJyb3dzZXJJbml0VGltZW91dFwiIG9wdGlvbiBpZiBpdCBpcyB0b28gbG93IChjdXJyZW50bHk6IHticm93c2VySW5pdFRpbWVvdXRNc2d9KS4gVGhpcyBvcHRpb24gZGV0ZXJtaW5lcyBob3cgbG9uZyBUZXN0Q2FmZSB3YWl0cyBmb3IgYnJvd3NlcnMgdG8gYmUgcmVhZHkuJyxcbiAgICBbQnJvd3NlckNvbm5lY3Rpb25FcnJvckhpbnQuUmVzdEVycm9yQ2F1c2VzXTogICAgICAgICAgICAgICAgICAgICdUaGUgZXJyb3IgY2FuIGFsc28gYmUgY2F1c2VkIGJ5IG5ldHdvcmsgaXNzdWVzIG9yIHJlbW90ZSBkZXZpY2UgZmFpbHVyZS4gTWFrZSBzdXJlIHRoYXQgeW91ciBuZXR3b3JrIGNvbm5lY3Rpb24gaXMgc3RhYmxlIGFuZCB5b3UgY2FuIHJlYWNoIHRoZSByZW1vdGUgZGV2aWNlLicsXG4gICAgW1JVTlRJTUVfRVJST1JTLmNhbm5vdEZpbmRUZXN0Y2FmZUNvbmZpZ3VyYXRpb25GaWxlXTogICAgICAgICAgICAnQ2Fubm90IGxvY2F0ZSBhIFRlc3RDYWZlIGNvbmZpZ3VyYXRpb24gZmlsZSBhdCB7ZmlsZVBhdGh9LiBFaXRoZXIgdGhlIGZpbGUgZG9lcyBub3QgZXhpc3QsIG9yIHRoZSBwYXRoIGlzIGludmFsaWQuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMuZGFzaGJvYXJkVG9rZW5JbkpTT05dOiAgICAgICAgICAgICAgICAgICAgICAgICAgICdJbnNlY3VyZSB0b2tlbiBkZWNsYXJhdGlvbjogY2Fubm90IGRlY2xhcmUgYSBEYXNoYm9hcmQgdG9rZW4gaW4gYSBKU09OIGNvbmZpZ3VyYXRpb24gZmlsZS4gVXNlIGEgSmF2YVNjcmlwdCBjb25maWd1cmF0aW9uIGZpbGUsIG9yIGRlY2xhcmUgYSBEYXNoYm9hcmQgdG9rZW4gd2l0aCBvbmUgb2YgdGhlIGZvbGxvd2luZzogdGhlIENMSSwgdGhlIFRlc3QgUnVubmVyIEFQSSwgdGhlIFRFU1RDQUZFX0RBU0hCT0FSRF9UT0tFTiBlbnZpcm9ubWVudCB2YXJpYWJsZS4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5yZWxhdGl2ZUJhc2VVcmxdOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1RoZSB2YWx1ZSBvZiB0aGUgYmFzZVVybCBhcmd1bWVudCBjYW5ub3QgYmUgcmVsYXRpdmU6IFwie2Jhc2VVcmx9XCInLFxuICAgIFtSVU5USU1FX0VSUk9SUy5yZXF1ZXN0VXJsSW52YWxpZFZhbHVlRXJyb3JdOiAgICAgICAgICAgICAgICAgICAgJ1JlcXVlc3RlZCB1cmwgaXNuXFwndCB2YWxpZCAoe2FjdHVhbFZhbHVlfSkuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMucmVxdWVzdFJ1bnRpbWVFcnJvcl06ICAgICAgICAgICAgICAgICAgICAgICAgICAgICdUaGUgcmVxdWVzdCB3YXMgaW50ZXJydXB0ZWQgYnkgYW4gZXJyb3I6XFxue21lc3NhZ2V9JyxcbiAgICBbUlVOVElNRV9FUlJPUlMuaW52YWxpZFNraXBKc0Vycm9yc09wdGlvbnNPYmplY3RQcm9wZXJ0eV06ICAgICAgIGBUaGUgXCJ7b3B0aW9uTmFtZX1cIiBvcHRpb24gZG9lcyBub3QgZXhpc3QuIFVzZSB0aGUgZm9sbG93aW5nIG9wdGlvbnMgdG8gY29uZmlndXJlIHNraXBKc0Vycm9yczogJHtnZXRDb25jYXRlbmF0ZWRWYWx1ZXNTdHJpbmcoT2JqZWN0LmtleXMoU0tJUF9KU19FUlJPUlNfT1BUSU9OU19PQkpFQ1RfT1BUSU9OX05BTUVTKSl9LmAsXG4gICAgW1JVTlRJTUVfRVJST1JTLmludmFsaWRTa2lwSnNFcnJvcnNDYWxsYmFja1dpdGhPcHRpb25zUHJvcGVydHldOiBgVGhlIFwie29wdGlvbk5hbWV9XCIgb3B0aW9uIGRvZXMgbm90IGV4aXN0LiBVc2UgdGhlIGZvbGxvd2luZyBvcHRpb25zIHRvIGNvbmZpZ3VyZSBza2lwSnNFcnJvcnMgY2FsbGJhY2s6ICR7Z2V0Q29uY2F0ZW5hdGVkVmFsdWVzU3RyaW5nKE9iamVjdC5rZXlzKFNLSVBfSlNfRVJST1JTX0NBTExCQUNLX1dJVEhfT1BUSU9OU19PUFRJT05fTkFNRVMpKX0uYCxcbiAgICBbUlVOVElNRV9FUlJPUlMuaW52YWxpZENvbW1hbmRJbkpzb25Db21waWxlcl06ICAgICAgICAgICAgICAgICAgIGBUZXN0Q2FmZSB0ZXJtaW5hdGVkIHRoZSB0ZXN0IHJ1bi4gVGhlIFwie3BhdGh9XCIgZmlsZSBjb250YWlucyBhbiB1bmtub3duIENocm9tZSBVc2VyIEZsb3cgYWN0aW9uIFwie2FjdGlvbn1cIi4gUmVtb3ZlIHRoZSBhY3Rpb24gdG8gY29udGludWUuIFJlZmVyIHRvIHRoZSBmb2xsb3dpbmcgYXJ0aWNsZSBmb3IgdGhlIGRlZmluaXRpdmUgbGlzdCBvZiBzdXBwb3J0ZWQgQ2hyb21lIFVzZXIgRmxvdyBhY3Rpb25zOiBodHRwczovL3Rlc3RjYWZlLmlvL2RvY3VtZW50YXRpb24vNDAzOTk4L2d1aWRlcy9leHBlcmltZW50YWwtY2FwYWJpbGl0aWVzL2Nocm9tZS1yZXBsYXktc3VwcG9ydCNzdXBwb3J0ZWQtcmVwbGF5LWFjdGlvbnNgLFxuICAgIFtSVU5USU1FX0VSUk9SUy5pbnZhbGlkQ3VzdG9tQWN0aW9uc09wdGlvblR5cGVdOiAgICAgICAgICAgICAgICAgYFRoZSB2YWx1ZSBvZiB0aGUgY3VzdG9tQWN0aW9ucyBvcHRpb24gZG9lcyBub3QgYmVsb25nIHRvIHR5cGUgT2JqZWN0LiBSZWZlciB0byB0aGUgZm9sbG93aW5nIGFydGljbGUgZm9yIGN1c3RvbSBhY3Rpb24gc2V0dXAgaW5zdHJ1Y3Rpb25zOiAkeyBET0NVTUVOVEFUSU9OX0xJTktTLkNVU1RPTV9BQ1RJT05TIH1gLFxuICAgIFtSVU5USU1FX0VSUk9SUy5pbnZhbGlkQ3VzdG9tQWN0aW9uVHlwZV06ICAgICAgICAgICAgICAgICAgICAgICAgYFRlc3RDYWZlIGNhbm5vdCBwYXJzZSB0aGUgXCJ7YWN0aW9uTmFtZX1cIiBhY3Rpb24sIGJlY2F1c2UgdGhlIGFjdGlvbiBkZWZpbml0aW9uIGlzIGludmFsaWQuIEZvcm1hdCB0aGUgZGVmaW5pdGlvbiBpbiBhY2NvcmRhbmNlIHdpdGggdGhlIGN1c3RvbSBhY3Rpb25zIGd1aWRlOiAkeyBET0NVTUVOVEFUSU9OX0xJTktTLkNVU1RPTV9BQ1RJT05TIH1gLFxuICAgIFtSVU5USU1FX0VSUk9SUy5jYW5ub3RJbXBvcnRFU01JbkNvbW1vbnNKU106ICAgICAgICAgICAgICAgICAgICAgJ0Nhbm5vdCBpbXBvcnQgdGhlIHtlc01vZHVsZX0gRUNNQVNjcmlwdCBtb2R1bGUgZnJvbSB7dGFyZ2V0RmlsZX0uIFVzZSBhIGR5bmFtaWMgaW1wb3J0KCkgc3RhdGVtZW50IG9yIGVuYWJsZSB0aGUgLS1lc20gQ0xJIGZsYWcuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMuc2V0TmF0aXZlQXV0b21hdGlvbkZvclVuc3VwcG9ydGVkQnJvd3NlcnNdOiAgICAgICdUaGUgXCJ7YnJvd3Nlcn1cIiBkbyBub3Qgc3VwcG9ydCB0aGUgTmF0aXZlIEF1dG9tYXRpb24gbW9kZS4gUmVtb3ZlIHRoZSBcIm5hdGl2ZSBhdXRvbWF0aW9uXCIgb3B0aW9uIHRvIGNvbnRpbnVlLicsXG59O1xuIl19